Trick 1
// given a number n upto 1e12 how many pairs are there that there gcd(i,j)==k?
// also we can get how many subset are there whose gcd=k
const int MX=100001;
vector<int> mu(MX);
vector<int> spf(MX);
vector<int> mu_pre(MX,0);
vector<int> primes;
void mobius_sieve(){
    mu[1]=1;
    for(int i=2;i<MX;i++){
        if(!spf[i]){
            spf[i]=i;
            mu[i]=-1;
            primes.PB(i);
        }
        for(int p:primes){
            if(i*p>=MX) break;
            spf[i*p]=p;
            if(!(i%p)){
                mu[i*p]=0;
                break;
            }else mu[i*p]-=mu[i];
        }
    }
    for(int i=1;i<MX;i++) mu_pre[i]=mu_pre[i-1]+mu[i];
}
// count gcd(i,j)==1 hard 
// but count of gcd(i,j)%k==0 is easy cause i%k==0 and j%k==0
// that is N/k this much value can be divide by k and pairs are (N/k)*(N/k)
ll count(int n,int k){ // count gcd(i,j)==k i,j<=n
    n/=k;
    if(!n) return 0;
    ll ans=0;
    for(int i=1;i<=n;i++){ // this will find in O(n)
        ll g_i=(n/i)*(n/i);
        ans+=1LL*mu[i]*g_i;
    }
    return ans;
}
ll count_faster(int n,int k){ // this will find in O(sqrt n)
    n/=k;
    if(!n) return 0;
    ll ans=0;
    for(int l=1;l<=n;){
        int val=n/l;
        int r=n/val;
        ll g_val=1LL*val*val;
        ll mu_sum=mu_pre[r]-mu_pre[l-1];
        ans+=mu_sum*g_val;
        l=r+1;
    }
    return ans;
}
---------------------------------------------------------------------------------
Trick 2
https://www.spoj.com/problems/GCDEX/
int mx=1000001;
vector<ll> phi(mx,0),spf(mx,0),pre_mu(mx,0),primes;
void mobius(){
  phi[1]=1;
  for(int i=2;i<mx;i++){
    if(!spf[i]){
      phi[i]=i-1;
      spf[i]=i;
      primes.PB(i);
    }
    for(auto u:primes){
      if(i*u>=mx) break;
      spf[i*u]=u;
      if(!(i%u)){
        phi[i*u]=phi[i]*u;
        break;
      }else phi[i*u]=phi[i]*(u-1);
    }
  }
  for(int i=1;i<mx;i++) pre_mu[i]=pre_mu[i-1]+phi[i];
}

ll count(ll n){
  ll ans=0;
  for(int i=1;i<=n;){
    ll val=n/i;
    if(!val) break;
    ll r=n/val;
    ll g_val=(val*(val-1))/2;
    ans+=g_val*(pre_mu[r]-pre_mu[i-1]);
    i=r+1;
  }
  return ans;
}
void GLITCH_(ll n) {
    cout<<count(n)<<endl;
    return;
}
----------------------------------------------------------------------------
#include"bits/stdc++.h"
using namespace std;
#define ll long long 
#define PB push_back
// Deploy mint function here **
int mx = 1000001;
vector<int> mu(mx),spf(mx,0),primes;
vector<mi>pow2(mx);
void mobius_sieve(){
    mu[1]=1;
    for(int i=2;i<mx;i++){
        if(!spf[i]){
            spf[i]=i;
            mu[i]=-1;
            primes.PB(i);
        }
        for(int p:primes){
            if(i*p>=mx) break;
            spf[i*p]=p;
            if(!(i%p)){
                mu[i*p]=0;
                break;
            }else mu[i*p]-=mu[i];
        }
    }
}
//*****
void solve_lcm(){ // ans for subsequence LCM=k;
  mobius_sieve();
  pow2[0]=1;
  for(int i=1;i<mx;i++) pow2[i]=pow2[i-1]*2;

  int n; cin>>n;
  map<int,int> freq;
  for(int i=1;i<=n;i++){
    int x; cin>>x;
    freq[x]++;
  }
  // now calculating the easy g[k] that is c[k]= count of numbers in A that divides k
  vector<int> c(mx,0);
  for(auto const& [val,count]:freq){
    for(int k=val;k<mx;k+=val)
      c[k]+=count;
  }
  vector<mi> g(mx);
  for(int k=1;k<mx;k++){
    g[k]=pow2[c[k]]-1;
  }
  // f[n] = sum( g[d] * mu[n/d] )
  vector<mi> f(mx,0);
  for(int d=1;d<mx;d++){
    // if(!g[d]) continue;
    for(int n=d;n<mx;n+=d)
      f[n]+=g[d]*mu[n/d];
  }
  // f[k] is the ans for subsequence LCM=k;
  int k; cin>>k;
  cout<<f[k]<<endl;
}
/*
*****Problem Statement: "Given N, and an alphabet of K letters, 
find the number of primitive strings of length n for all n from 1 to N."
(A string is primitive if it's not a repetition of a smaller block, 
e.g., "abcab" is primitive, but "ababab" is not).
*/
void solve_primitive_strings(){
  int n=100000,k=26;
  mobius_sieve();
  vector<mi> g(n+1);
  g[0]=1;
  for(int i=1;i<=n;i++) g[i]=g[i-1]*k;

  vector<mi> f(mx,0);
  for(int d=1;d<mx;d++){
    // if(!g[d]) continue;
    for(int n=d;n<mx;n+=d)
      f[n]+=g[d]*mu[n/d];
  }
  // cout << "Primitive strings of length 4 (K=26): " << f[4] << endl;
}
int32_t main(){
  solve_lcm();
}




/*
cout << "### Example 1: Basic Arithmetic ###" << endl;
mi a = 1'000'000'000; // 1 billion
mi b = 10;
cout << "a + b = " << (a + b) << endl; 
cout << "b - a = " << (b - a) << endl;
cout << "a * b = " << (a * b) << endl;

cout << "### Example 2: Division and Power ###" << endl;

// Calculate 2^100 % MOD
mi p = pow(mi(2), 100);
cout << "2^100 = " << p << endl;
// Calculate (2^100 / 2)
mi p_div_2 = p / mi(2);
cout << "2^100 / 2 = " << p_div_2 << endl;

cout << "### Example 3: O(N) Factorial Method ###" << endl;
// We must call precompute() first.
mi::precompute(1000); // Pre-calculate factorials up to 1000
cout << "10C3 (from nCr) = " << mi::nCr(10, 3) << endl;
cout << "10P3 (from nPr) = " << mi::nPr(10, 3) << endl;

cout << "### Example 4: O(N^2) genComb Method ###" << endl;
// We must call genComb() first.
mi::genComb(100); // Pre-calculate a 100x100 table
cout << "10C3 (from scmb) = " << mi::scmb[10][3] << endl;
cout << "50C25 (from scmb) = " << mi::scmb[50][25] << endl;
*/